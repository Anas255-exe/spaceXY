<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ANAS.EXE — SPACE SHOOTER</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Press Start 2P', monospace;
    overflow: hidden;
  }

  #wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  #title {
    color: #00ff88;
    font-size: 11px;
    letter-spacing: 3px;
    text-shadow: 0 0 10px #00ff88, 0 0 30px #00ff8855;
    animation: flicker 3s infinite;
  }

  @keyframes flicker {
    0%,95%,100% { opacity: 1; }
    96% { opacity: 0.4; }
    98% { opacity: 0.8; }
  }

  #hud {
    display: flex;
    gap: 30px;
    font-size: 7px;
    color: #aaa;
  }

  #hud span { color: #00ff88; }

  canvas {
    border: 1px solid #00ff8833;
    box-shadow: 0 0 40px #00ff8822, inset 0 0 60px #00000088;
    image-rendering: pixelated;
    cursor: none;
  }

  #controls {
    font-size: 6px;
    color: #444;
    letter-spacing: 1px;
    text-align: center;
    line-height: 2;
  }

  #controls b { color: #00ff8866; }

  #overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #000000cc;
    gap: 18px;
    z-index: 10;
  }

  #overlay h1 {
    font-size: 22px;
    color: #00ff88;
    text-shadow: 0 0 20px #00ff88;
    animation: pulse 1s infinite alternate;
  }

  @keyframes pulse {
    from { text-shadow: 0 0 10px #00ff88; }
    to   { text-shadow: 0 0 30px #00ff88, 0 0 60px #00ff8844; }
  }

  #overlay p {
    font-size: 7px;
    color: #666;
    text-align: center;
    line-height: 2.5;
  }

  #overlay .sub {
    font-size: 8px;
    color: #00ff8888;
    letter-spacing: 2px;
  }

  #startBtn {
    font-family: 'Press Start 2P', monospace;
    font-size: 9px;
    background: transparent;
    color: #00ff88;
    border: 2px solid #00ff88;
    padding: 10px 22px;
    cursor: pointer;
    letter-spacing: 2px;
    transition: all 0.1s;
    text-shadow: 0 0 8px #00ff88;
    box-shadow: 0 0 12px #00ff8833;
  }

  #startBtn:hover {
    background: #00ff8822;
    box-shadow: 0 0 24px #00ff8866;
  }

  #scanlines {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.08) 2px,
      rgba(0,0,0,0.08) 4px
    );
    pointer-events: none;
    z-index: 100;
  }
</style>
</head>
<body>

<div id="scanlines"></div>

<div id="wrapper">
  <div id="title">✦ ANAS.EXE ✦</div>
  <div id="hud">
    SCORE: <span id="scoreDisplay">0</span>
    &nbsp;&nbsp;&nbsp;
    LIVES: <span id="livesDisplay">♥ ♥ ♥</span>
    &nbsp;&nbsp;&nbsp;
    WAVE: <span id="waveDisplay">1</span>
  </div>

  <canvas id="game" width="480" height="520"></canvas>

  <div id="controls">
    <b>← →</b> MOVE &nbsp;|&nbsp; <b>SPACE</b> SHOOT &nbsp;|&nbsp; <b>TOUCH</b> DRAG TO MOVE
  </div>
</div>

<!-- Overlay -->
<div id="overlay">
  <div class="sub">— INCOMING —</div>
  <h1>SPACE<br/>ANAS</h1>
  <p>
    DEFEND THE GALAXY<br/>
    DESTROY ALL METEORS<br/>
    DON'T GET HIT
  </p>
  <button id="startBtn" onclick="startGame()">► LAUNCH</button>
  <p style="color:#333;font-size:5px;margin-top:8px">ARROWS / WASD · SPACE TO SHOOT</p>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const W = canvas.width;
const H = canvas.height;

// ── State ──────────────────────────────────────────────
let score = 0, lives = 3, wave = 1, gameRunning = false;
let keys = {};
let stars = [], meteors = [], bullets = [], particles = [], powerups = [];
let ship = { x: W/2, y: H - 70, w: 24, h: 28, speed: 4, shootCooldown: 0, invincible: 0 };
let frameCount = 0;
let touchX = null;

// ── Pixel art drawers ───────────────────────────────────

function drawShip(x, y, flicker) {
  if (flicker && Math.floor(Date.now()/100)%2===0) return;
  const px = 3;
  // ship pixel map (8x10)
  const map = [
    [0,0,0,1,1,0,0,0],
    [0,0,1,1,1,1,0,0],
    [0,0,1,2,2,1,0,0],
    [0,1,1,2,2,1,1,0],
    [1,1,1,1,1,1,1,1],
    [1,3,1,1,1,1,3,1],
    [0,1,1,1,1,1,1,0],
    [0,0,1,0,0,1,0,0],
    [0,1,0,0,0,0,1,0],
    [0,1,0,0,0,0,1,0],
  ];
  const colors = { 1:'#00ff88', 2:'#ffffff', 3:'#ff4466' };
  const ox = x - (map[0].length * px)/2;
  const oy = y - (map.length * px)/2;
  map.forEach((row, r) => row.forEach((c, col) => {
    if (!c) return;
    ctx.fillStyle = colors[c];
    ctx.fillRect(ox + col*px, oy + r*px, px, px);
  }));
  // engine glow
  if (frameCount % 6 < 3) {
    ctx.fillStyle = '#ff8800';
    ctx.fillRect(ox + 3*px, oy + 10*px, px, px);
    ctx.fillRect(ox + 4*px, oy + 10*px, px, px);
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(ox + 3*px, oy + 11*px, px, px/2);
    ctx.fillRect(ox + 4*px, oy + 11*px, px, px/2);
  }
}

function drawMeteor(m) {
  const px = m.px;
  // varied meteor shapes based on type
  const maps = [
    [ // round
      [0,1,1,1,0],
      [1,1,2,1,1],
      [1,2,1,2,1],
      [1,1,2,1,1],
      [0,1,1,1,0],
    ],
    [ // jagged
      [0,0,1,1,0],
      [0,1,1,1,1],
      [1,1,2,1,0],
      [0,1,1,1,1],
      [0,0,1,0,0],
    ],
    [ // big chunky
      [0,1,1,1,1,0],
      [1,1,2,1,1,1],
      [1,2,1,2,1,1],
      [1,1,1,2,1,0],
      [0,1,1,1,1,0],
    ],
  ];
  const map = maps[m.shape % maps.length];
  const cols = map[0].length;
  const rows = map.length;
  const ox = m.x - (cols * px)/2;
  const oy = m.y - (rows * px)/2;
  map.forEach((row, r) => row.forEach((c, col) => {
    if (!c) return;
    ctx.fillStyle = c === 2 ? '#886644' : m.color;
    ctx.fillRect(ox + col*px, oy + r*px, px, px);
  }));
}

function drawBullet(b) {
  ctx.fillStyle = '#ffff44';
  ctx.fillRect(b.x - 2, b.y - 5, 4, 10);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(b.x - 1, b.y - 5, 2, 3);
}

function drawParticle(p) {
  ctx.globalAlpha = p.life / p.maxLife;
  ctx.fillStyle = p.color;
  ctx.fillRect(p.x, p.y, p.size, p.size);
  ctx.globalAlpha = 1;
}

function drawPowerup(p) {
  const blink = Math.floor(frameCount/8)%2;
  ctx.fillStyle = blink ? '#ff44ff' : '#ff88ff';
  ctx.fillRect(p.x - 6, p.y - 6, 12, 12);
  ctx.fillStyle = '#ffffff';
  ctx.font = '8px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('★', p.x + 1, p.y + 3);
}

// ── Spawning ───────────────────────────────────────────

function spawnStars() {
  for (let i = 0; i < 80; i++) {
    stars.push({
      x: Math.random() * W,
      y: Math.random() * H,
      size: Math.random() < 0.8 ? 1 : 2,
      speed: 0.2 + Math.random() * 0.5,
      brightness: 0.3 + Math.random() * 0.7
    });
  }
}

function spawnMeteor() {
  const shapes = ['round','jagged','chunk'];
  const colors = ['#aa6633','#bb7744','#cc8855','#997755'];
  const size = 1 + Math.floor(Math.random() * 2 + wave * 0.3);
  meteors.push({
    x: 20 + Math.random() * (W - 40),
    y: -20,
    w: size * 5, h: size * 5,
    px: size + 2,
    shape: Math.floor(Math.random() * 3),
    color: colors[Math.floor(Math.random() * colors.length)],
    speed: 1 + Math.random() * 1.5 + wave * 0.2,
    vx: (Math.random() - 0.5) * 1.5,
    hp: size,
    maxHp: size,
  });
}

function spawnParticles(x, y, color, count = 12) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
    const speed = 1 + Math.random() * 3;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      size: 2 + Math.floor(Math.random() * 3),
      color,
      life: 30 + Math.random() * 20,
      maxLife: 50,
    });
  }
}

// ── Background nebula ──────────────────────────────────

function drawBackground() {
  // Deep space gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0,   '#000010');
  grad.addColorStop(0.5, '#00000a');
  grad.addColorStop(1,   '#050015');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Nebula blobs
  const nebulas = [
    { x: 80,  y: 120, r: 80,  c: '#1a0030' },
    { x: 350, y: 250, r: 100, c: '#001a20' },
    { x: 200, y: 380, r: 70,  c: '#0a001a' },
  ];
  nebulas.forEach(n => {
    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
    g.addColorStop(0, n.c);
    g.addColorStop(1, 'transparent');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);
  });

  // Stars
  stars.forEach(s => {
    ctx.globalAlpha = s.brightness * (0.7 + 0.3 * Math.sin(frameCount * 0.05 + s.x));
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(s.x, s.y, s.size, s.size);
  });
  ctx.globalAlpha = 1;
}

// ── Collision ─────────────────────────────────────────

function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

// ── HUD ───────────────────────────────────────────────

function drawHUD() {
  // Wave banner
  if (frameCount < 120) {
    ctx.globalAlpha = Math.min(1, (120 - frameCount) / 30);
    ctx.fillStyle = '#00ff88';
    ctx.font = '10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(`WAVE ${wave}`, W/2, H/2 - 10);
    ctx.globalAlpha = 1;
  }

  // Pixel health bar
  for (let i = 0; i < 3; i++) {
    ctx.fillStyle = i < lives ? '#ff4466' : '#222';
    ctx.fillRect(10 + i * 14, H - 14, 10, 8);
  }
}

// ── Update ────────────────────────────────────────────

function update() {
  frameCount++;

  // Move stars
  stars.forEach(s => {
    s.y += s.speed;
    if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
  });

  // Ship movement
  let moving = false;
  if (keys['ArrowLeft']  || keys['a'] || keys['A']) { ship.x -= ship.speed; moving = true; }
  if (keys['ArrowRight'] || keys['d'] || keys['D']) { ship.x += ship.speed; moving = true; }
  if (keys['ArrowUp']    || keys['w'] || keys['W']) { ship.y -= ship.speed * 0.6; }
  if (keys['ArrowDown']  || keys['s'] || keys['S']) { ship.y += ship.speed * 0.6; }

  // Touch follow
  if (touchX !== null) {
    const diff = touchX - ship.x;
    ship.x += Math.sign(diff) * Math.min(Math.abs(diff) * 0.15, ship.speed);
  }

  ship.x = Math.max(20, Math.min(W - 20, ship.x));
  ship.y = Math.max(H * 0.4, Math.min(H - 30, ship.y));

  // Auto-shoot
  ship.shootCooldown--;
  if (ship.shootCooldown <= 0 && (keys[' '] || keys['z'] || keys['Z'] || touchX !== null)) {
    bullets.push({ x: ship.x, y: ship.y - 20, speed: 9 });
    ship.shootCooldown = 12;
  }

  if (ship.invincible > 0) ship.invincible--;

  // Bullets
  bullets = bullets.filter(b => b.y > -10);
  bullets.forEach(b => b.y -= b.speed);

  // Meteors
  const spawnRate = Math.max(40 - wave * 3, 18);
  if (frameCount % spawnRate === 0) spawnMeteor();

  meteors.forEach(m => {
    m.y += m.speed;
    m.x += m.vx;
    if (m.x < 10 || m.x > W - 10) m.vx *= -1;
  });

  // Bullet vs meteor
  bullets.forEach((b, bi) => {
    meteors.forEach((m, mi) => {
      if (rectsOverlap(b.x-2, b.y-5, 4, 10, m.x - m.px*2, m.y - m.px*2, m.px*4, m.px*4)) {
        bullets.splice(bi, 1);
        m.hp--;
        spawnParticles(b.x, b.y, '#ffaa44', 6);
        if (m.hp <= 0) {
          spawnParticles(m.x, m.y, m.color, 16);
          spawnParticles(m.x, m.y, '#ff8800', 8);
          score += m.maxHp * 10;
          meteors.splice(mi, 1);
          if (Math.random() < 0.08) powerups.push({ x: m.x, y: m.y, vy: 1 });
        }
      }
    });
  });

  // Ship vs meteor
  meteors = meteors.filter(m => {
    if (m.y > H + 30) return false;
    if (ship.invincible === 0 && rectsOverlap(
      ship.x - 10, ship.y - 12, 20, 24,
      m.x - m.px*2, m.y - m.px*2, m.px*4, m.px*4
    )) {
      lives--;
      ship.invincible = 120;
      spawnParticles(ship.x, ship.y, '#00ff88', 20);
      spawnParticles(m.x, m.y, m.color, 12);
      meteors.splice(meteors.indexOf(m), 1);
      if (lives <= 0) endGame();
      return false;
    }
    return true;
  });

  // Powerups
  powerups.forEach((p, i) => {
    p.y += p.vy;
    if (rectsOverlap(ship.x-10, ship.y-12, 20, 24, p.x-6, p.y-6, 12, 12)) {
      lives = Math.min(lives + 1, 5);
      spawnParticles(p.x, p.y, '#ff44ff', 14);
      powerups.splice(i, 1);
    }
    if (p.y > H + 20) powerups.splice(i, 1);
  });

  // Particles
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.05;
    p.life--;
  });
  particles = particles.filter(p => p.life > 0);

  // Wave progression
  if (frameCount % 600 === 0) wave++;

  // Update HUD
  document.getElementById('scoreDisplay').textContent = score;
  document.getElementById('livesDisplay').textContent = '♥ '.repeat(Math.max(0,lives)).trim();
  document.getElementById('waveDisplay').textContent = wave;
}

// ── Draw ──────────────────────────────────────────────

function draw() {
  drawBackground();
  powerups.forEach(drawPowerup);
  meteors.forEach(drawMeteor);
  bullets.forEach(drawBullet);
  particles.forEach(drawParticle);
  drawShip(ship.x, ship.y, ship.invincible > 0);
  drawHUD();
}

// ── Loop ──────────────────────────────────────────────

function loop() {
  if (!gameRunning) return;
  update();
  draw();
  requestAnimationFrame(loop);
}

// ── Init / End ────────────────────────────────────────

function startGame() {
  document.getElementById('overlay').style.display = 'none';
  score = 0; lives = 3; wave = 1; frameCount = 0;
  meteors = []; bullets = []; particles = []; powerups = [];
  ship = { x: W/2, y: H - 70, w: 24, h: 28, speed: 4, shootCooldown: 0, invincible: 60 };
  stars = [];
  spawnStars();
  gameRunning = true;
  loop();
}

function endGame() {
  gameRunning = false;
  const ov = document.getElementById('overlay');
  ov.innerHTML = `
    <div class="sub">— GAME OVER —</div>
    <h1>YOU DIED</h1>
    <p>SCORE: ${score}<br/>WAVE REACHED: ${wave}</p>
    <button id="startBtn" onclick="startGame()">► RETRY</button>
  `;
  ov.style.display = 'flex';
}

// ── Controls ──────────────────────────────────────────

document.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === ' ') e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
  keys[' '] = true;
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
}, { passive: false });

canvas.addEventListener('touchend', () => {
  touchX = null;
  keys[' '] = false;
});

// Draw idle background while on title screen
spawnStars();
(function idleLoop() {
  if (gameRunning) return;
  frameCount++;
  stars.forEach(s => { s.y += s.speed; if (s.y > H) { s.y = 0; s.x = Math.random() * W; } });
  drawBackground();
  drawShip(W/2, H - 70, false);
  requestAnimationFrame(idleLoop);
})();
</script>
</body>
</html>
